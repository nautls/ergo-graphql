# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type AdProof {
  digest: String!
  header: Header!
  headerId: String!
  proofBytes: String!
}

type Address {
  address: String!
  balance: AddressBalance!
  transactionsCount: Int!
}

type AddressAssetBalance {
  amount: BigInt!
  decimals: Int
  name: String
  tokenId: String!
}

type AddressBalance {
  assets(tokenId: String): [AddressAssetBalance!]!
  nanoErgs: BigInt!
}

type Asset implements IAsset {
  amount: BigInt!
  box: Box!
  boxId: String!
  headerId: String!
  index: Int!
  token: Token!
  tokenId: String!
}

input AssetInput {
  amount: Int!
  tokenId: String!
}

scalar BigInt

type Block {
  blockChainTotalSize: BigInt!
  blockCoins: BigInt!
  blockFee: BigInt!
  blockMiningTime: BigInt!
  blockSize: Int!
  difficulty: BigInt!
  header: Header!
  headerId: String!
  height: Int!
  mainChain: Boolean!
  maxBoxGix: BigInt!
  maxTxGix: BigInt!
  minerAddress: String!
  minerRevenue: BigInt!
  minerReward: BigInt!
  timestamp: BigInt!
  totalCoinsInTxs: BigInt!
  totalCoinsIssued: BigInt!
  totalFees: BigInt!
  totalMinersReward: BigInt!
  totalMiningTime: BigInt!
  totalTxsCount: BigInt!
  txsCount: Int!
  txsSize: Int!
}

type Box implements IBox {
  additionalRegisters: JSON!
  address: String!
  assets: [Asset!]!
  boxId: String!
  creationHeight: Int!
  ergoTree: String!
  ergoTreeTemplateHash: String!
  globalIndex: BigInt!
  headerId: String!
  index: Int!
  mainChain: Boolean!
  settlementHeight: Int!
  spentBy: Input
  transaction: Transaction!
  transactionId: String!
  value: BigInt!
}

type DataInput implements IDataInput {
  box: Box!
  boxId: String!
  headerId: String!
  index: Int!
  mainChain: Boolean!
  transaction: Transaction!
  transactionId: String!
}

type Epochs {
  blockVersion: Int!
  dataInputCost: Int!
  height: Int!
  id: Int!
  inputCost: Int!
  maxBlockCost: Int!
  maxBlockSize: Int!
  minValuePerByte: Int!
  outputCost: Int!
  storageFeeFactor: Int!
  tokenAccessCost: Int!
}

type Extension {
  digest: String!
  fields: JSON!
  headerId: String!
}

type Header {
  adProof: AdProof!
  adProofsRoot: String!
  blockInfo: Block!
  difficulty: BigInt!
  extension: Extension!
  extensionHash: String!
  headerId: String!
  height: Int!
  mainChain: Boolean!
  nBits: BigInt!
  parentId: String!
  powSolutions: JSON!
  stateRoot: String!
  timestamp: BigInt!
  transactionsRoot: String!
  version: Int!
  votes: [Int!]!
}

interface IAsset {
  amount: BigInt!
  boxId: String!
  index: Int!
  tokenId: String!
}

interface IBox {
  additionalRegisters: JSON!
  address: String!
  boxId: String!
  creationHeight: Int!
  ergoTree: String!
  ergoTreeTemplateHash: String!
  index: Int!
  transactionId: String!
  value: BigInt!
}

interface IDataInput {
  boxId: String!
  index: Int!
  transactionId: String!
}

interface IInput {
  boxId: String!
  extension: JSON!
  index: Int!
  proofBytes: String
  transactionId: String!
}

interface ITransaction {
  size: Int!
  transactionId: String!
}

type Input implements IInput {
  box: Box!
  boxId: String!
  extension: JSON!
  headerId: String!
  index: Int!
  mainChain: Boolean!
  proofBytes: String
  transaction: Transaction!
  transactionId: String!
}

scalar JSON

type Mempool {
  addresses(addresses: [String!]!): [UnconfirmedAddress!]!
  boxes(address: String, boxId: String, ergoTreeTemplateHash: String, skip: Int = 0, take: Int = 50, transactionId: String): [UnconfirmedBox!]!
  size: Int!
  transactions(skip: Int = 0, take: Int = 50, transactionId: String): [UnconfirmedTransaction!]!
  transactionsCount: Int!
}

type Mutation {
  checkTransaction(signedTransaction: SignedTransaction!): String!
  submitTransaction(signedTransaction: SignedTransaction!): String!
}

type Query {
  addresses(addresses: [String!]!, atHeight: Int): [Address!]!
  blockHeaders(headerId: String, height: Int, parentId: String, skip: Int = 0, take: Int = 10): [Header!]!
  blocks(headerId: String, height: Int, skip: Int = 0, take: Int = 10): [Block!]!
  boxes(address: String, boxId: String, ergoTree: String, ergoTreeTemplateHash: String, headerId: String, registers: Registers, skip: Int = 0, spent: Boolean, take: Int = 50, tokenId: String, transactionId: String): [Box!]!
  dataInputs(boxId: String, headerId: String, skip: Int = 0, take: Int = 50, transactionId: String): [DataInput!]!
  epochs(height: Int, id: Int, skip: Int = 0, take: Int = 50): [Epochs!]!
  inputs(boxId: String, headerId: String, skip: Int = 0, take: Int = 50, transactionId: String): [Input!]!
  mempool: Mempool!
  tokens(boxId: String, name: String, skip: Int = 0, take: Int = 50, tokenId: String): [Token!]!
  transactions(address: String, headerId: String, inclusionHeight: Int, maxHeight: Int, minHeight: Int, skip: Int = 0, take: Int = 50, transactionId: String): [Transaction!]!
}

input Registers {
  R4: String
  R5: String
  R6: String
  R7: String
  R8: String
  R9: String
}

input SignedTransaction {
  dataInputs: [TransactionDataInput!]!
  id: String!
  inputs: [TransactionInput!]!
  outputs: [TransactionOutput!]!
  size: Int!
}

input SpendingProofInput {
  extension: JSON!
  proofBytes: String!
}

type Token {
  box: Box!
  boxId: String!
  decimals: Int
  description: String
  emissionAmount: BigInt!
  name: String
  tokenId: String!
  type: String
}

type Transaction implements ITransaction {
  coinbase: Boolean!
  dataInputs: [DataInput!]!
  globalIndex: BigInt!
  headerId: String!
  inclusionHeight: Int!
  index: Int!
  inputs: [Input!]!
  mainChain: Boolean!
  outputs(
    """Only includes outputs owned by `address` and the miner fee output"""
    onlyRelevant: Boolean
  ): [Box!]!
  size: Int!
  timestamp: BigInt!
  transactionId: String!
}

input TransactionDataInput {
  boxId: String!
}

input TransactionInput {
  boxId: String!
  spendingProof: SpendingProofInput!
}

input TransactionOutput {
  additionalRegisters: JSON!
  assets: AssetInput!
  boxId: String!
  creationHeight: Int!
  ergoTree: String!
  index: Int!
  transactionId: String!
  value: Int!
}

type UnconfirmedAddress {
  address: String!
  balance: AddressBalance!
}

type UnconfirmedAsset implements IAsset {
  amount: BigInt!
  boxId: String!
  index: Int!
  token: Token!
  tokenId: String!
}

type UnconfirmedBox implements IBox {
  additionalRegisters: JSON!
  address: String!
  assets: [UnconfirmedAsset!]!
  boxId: String!
  creationHeight: Int!
  ergoTree: String!
  ergoTreeTemplateHash: String!
  index: Int!
  transaction: UnconfirmedTransaction!
  transactionId: String!
  value: BigInt!
}

type UnconfirmedDataInput implements IDataInput {
  boxId: String!
  index: Int!
  transaction: UnconfirmedTransaction!
  transactionId: String!
}

type UnconfirmedInput implements IInput {
  boxId: String!
  extension: JSON!
  index: Int!
  proofBytes: String
  transaction: UnconfirmedTransaction!
  transactionId: String!
}

type UnconfirmedTransaction implements ITransaction {
  dataInputs: [UnconfirmedDataInput!]!
  inputs: [UnconfirmedInput!]!
  outputs: [UnconfirmedBox!]!
  size: Int!
  timestamp: BigInt!
  transactionId: String!
}
